# Ex2_1
This program contains three methods for counting the number of lines in an array of text files.

## createTextFiles(int n, int seed, int bound)
This method creates a specified number of text files with random content.

Parameters

n: the number of files to create
seed: the seed for the random number generator
bound: the upper bound for the random numbers generated by the random number generator
Returns

an array of strings containing the names of the created files
Throws

FileNotFoundException: if the file cannot be created
UnsupportedEncodingException: if the encoding is not supported
## getNumOfLines(String[] fileNames)
This method returns the number of lines in the specified array of files.

Parameters

fileNames: an array of file names
Returns

the number of lines in the files
## getNumOfLinesThreads(String[] fileNames)
This method returns the number of lines in the specified array of files using separate threads for each file.

Parameters

fileNames: an array of file names
Returns

the number of lines in the files
Throws

InterruptedException: if any thread has interrupted the current thread
## getNumOfLinesThreadPool(String[] fileNames)
This method returns the number of lines in the specified array of files using a thread pool.

Parameters

fileNames: an array of file names
Returns

the number of lines in the files
Throws

ExecutionException: if the computation threw an exception
InterruptedException: if the current thread was interrupted while waiting
callCountLines
This is a Callable task that counts the number of lines in a file. It is used by the getNumOfLinesThreadPool method.![ex2_1]

## outcome&& what we learned
The performance of executing regular tasks can be improved by using threads. Threads allow for multiple tasks to be executed simultaneously, reducing the overall processing time. In the provided example, the elapsed time for the task "getNumOfLines()" was 3874 milliseconds. However, when using threads, the same task was completed in 416 milliseconds, as seen in the "getNumOfLinesThreads()" test. This represents a significant improvement in performance.
A thread pool takes this a step further by pre-instantiating a group of reusable threads, reducing the overhead associated with creating and destroying threads. The "getNumOfLinesThreadPool()" test in the provided example had an elapsed time of 541 milliseconds, which is faster than using regular thread, but slower than using a Thread pool. This demonstrates the added benefits of using a thread pool in terms of performance.

Elapsed time for getNumOfLines(): 3874 milliseconds

Elapsed time for getNumOfLinesThreads(): 416 milliseconds

Elapsed time for getNumOfLinesThreadPool(): 541 milliseconds

![alt text](https://user-images.githubusercontent.com/117913057/212166599-7cc52ec1-0e22-4ee1-903a-831639ed603a.png)


# Ex2_2
This code provides a custom implementation of thread pool and task management in Java. It includes the following classes:

CustomExecutor: a custom thread pool that creates a thread pool with a minimum of half of the number of cores on the system minus 1 and a maximum of the number of cores minus 1. It uses a PriorityBlockingQueue to hold the tasks that are submitted to it. It also has methods to submit tasks, gracefully terminate the thread pool, and get the current max priority value.
Task: a custom implementation of the FutureTask class in Java. It accepts a callable object and a task type. It also implements the Comparable interface, and the compareTo method compares tasks based on their priority values.
TaskType: an enumeration that contains different types of tasks, each with a different priority value. It has methods to get and set the priority value, get the task type, and validate the priority.
Usage

## using adapter design pattern
The Adapter design pattern is a structural pattern that allows objects with incompatible interfaces to work together. It is used to convert the interface of a class into another interface that the client expects. The Adapter pattern allows the client to call methods on the adapter that are then translated to calls on the adaptee class.

In the provided code, the Adapter pattern is used to adapt the Callable interface to the custom Task class. The Task class is a custom implementation of the FutureTask class with added functionality for task types and priority values. The submit() method of the CustomExecutor class is overridden to accept tasks of the custom Task class and use the task's priority value to sort the tasks in the queue. The Task.createTask(Callable<T> operation, TaskType type) factory method is used to create an instance of the Task class and adapt a Callable object to it. This allows the CustomExecutor to use the custom Task class while still being able to accept Callable objects as tasks.
 
    ## using SOLID desgin pattern
  In the provided code, SOLID principles are implemented to ensure maintainability and extensibility of the code. The Single Responsibility Principle is applied by ensuring that each class has a single, well-defined responsibility. The Task class has the single responsibility of executing a Callable operation and providing additional functionality for task types and priority values. The CustomExecutor class also has a single responsibility of managing the execution of tasks, submitting tasks, and sorting the tasks based on their priority values.

Additionally, the Factory Method pattern is used in the Task class to create instances of the Task class and adapt a Callable object to it. This helps in adhering to the Open-Closed Principle, which states that a class should be open for extension but closed for modification. This pattern allows for creating new objects without modifying the existing ones and making the code more extensible.
 
 ## using a factory method
  The Factory Method design pattern is a creational pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created. In the provided code, the Factory Method design pattern is used in the Task class to create an instance of the Task class and adapt a Callable object to it. The Task.createTask(Callable<T> operation, TaskType type) factory method is used to create an instance of the Task class, it takes a Callable object and a TaskType enumeration as input. The method wraps the Callable object within a Task instance and assigns the passed TaskType to it. This allows for a simplified and flexible way for creating Task objects and ensures that all Task objects created with this method have a TaskType and a Callable operation associated with it.


 
 
![alt text](https://user-images.githubusercontent.com/117913057/212170096-e2e23fa2-d340-4589-9d6b-438de015fd25.png)
