package Ex2_1;

import java.io.*;
import java.util.Random;
import java.util.concurrent.*;
import java.util.List;
import java.util.ArrayList;


public class Ex2_1 {
    /**
     * Creates a specified number of text files with random content.
     *
     * @param n     the number of files to create
     * @param seed  the seed for the random number generator
     * @param bound the upper bound for the random numbers generated by the random number generator
     * @return an array of strings containing the names of the created files
     * @throws FileNotFoundException        if the file cannot be created
     * @throws UnsupportedEncodingException if the encoding is not supported
     */
    public static String[] createTextFiles(int n, int seed, int bound) throws FileNotFoundException, UnsupportedEncodingException {
        String[] fileArr = new String[n];
        String namingFiles = "file_";
        Random rand = new Random(seed);
        for (int i = 0; i < n; i++) {
            String namingFilesWithNum = namingFiles + i;
            File file = new File(namingFilesWithNum + ".txt");
            PrintWriter writer = new PrintWriter(file);
            int x = rand.nextInt(bound);
            String writerInput = "";
            String string =  ("Yovel and Noam Assignment_2_OOP \r\n");
            for (int j = 0; j < x; j++) {
                writerInput += string;
            }
            writer.println(writerInput);
            writer.close();
            fileArr[i] = namingFilesWithNum + ".txt";
        }
        return fileArr;
    }

    public static int readSumFile(String file) {
        int numOfLines = 0;
        try {
            BufferedReader reader = new BufferedReader(new FileReader(file));
            while (reader.readLine() != null) {
                numOfLines++;
            }
            reader.close();
        } catch (Exception e) {
            e.getStackTrace();
        }
        return numOfLines-1;
    }

    /**
     * Returns the number of lines in the specified array of files.
     *
     * @param fileNames an array of file names
     * @return the number of lines in the files
     */
    public static int getNumOfLines(String[] fileNames) {
        int numOfLines = 0;
        for (int i = 0; i < fileNames.length; i++) {
            numOfLines = numOfLines + readSumFile(fileNames[i]);
        }
        return numOfLines;
    }


    /**
     * A thread that counts the number of lines in a file.
     */
    public static class fileThread extends Thread {
        private String fileName;
        private int lineCountCons;

        public fileThread(String fileName) {
            this.fileName = fileName;
            this.lineCountCons = 0;
        }

        @Override
        public void run() {
            int lineCount = readSumFile(fileName);
            this.lineCountCons = lineCount;
        }

        public int getLineCount() {
            return lineCountCons;
        }
    }

    /**
     * Returns the number of lines in the specified array of files using separate threads for each file.
     *
     * @param fileNames an array of file names
     * @return the number of lines in the files
     */
    public static int getNumOfLinesThreads(String[] fileNames) {
        int count = fileNames.length, i = 0,j=0, numOfLines = 0;
        fileThread[] arr = new fileThread[count];
        while (i < count) {
            fileThread file = new fileThread(fileNames[i]);
            arr[i] = file;
            file.start();
            i++;
        }
        i = 0;
        while (j < count) {
            try {
                arr[j].join();
            }
            catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            numOfLines  += arr[j].getLineCount();
            j++;
        }
        return numOfLines;
    }

    /**
     * A Callable task that counts the number of lines in a file.
     */
    public static class callCountLines implements Callable<Integer> {
        private String fileName;

        public callCountLines(String fileName) {
            this.fileName = fileName;
        }

        @Override
        public Integer call() throws Exception {
            int lineCount = readSumFile(fileName);
            return lineCount;
        }
    }

    /**
     * Returns the number of lines in the specified array of files using a thread pool.
     *
     * @param fileNames an array of file names
     * @return the number of lines in the files
     * @throws ExecutionException   if the task throws an exception
     * @throws InterruptedException if the current thread was interrupted while waiting
     */
    public static int getNumOfLinesThreadPool(String[] fileNames) throws ExecutionException, InterruptedException {
        int poolSize = fileNames.length;
//        int poolSize = fileNames.length/10;
        ExecutorService executor = Executors.newFixedThreadPool(poolSize);
        List<Future<Integer>> futures = new ArrayList<>();
        for (String fileName : fileNames) {
            Callable<Integer> task = new callCountLines(fileName);
            Future<Integer> future = executor.submit(task);
            futures.add(future);
        }
        int sumOfLines = 0;
        for (Future<Integer> future : futures) {
            sumOfLines += future.get();
        }
        executor.shutdownNow();
        return sumOfLines ;
    }

    public static void main(String[] args) throws FileNotFoundException, UnsupportedEncodingException, ExecutionException, InterruptedException {
        String[] fileNames = Ex2_1.createTextFiles(10, 3, 4);
        // Measure the execution time of the getNumOfLines() method
        long startTime = System.currentTimeMillis();
        int numOfLines = Ex2_1.getNumOfLines(fileNames);
        long endTime = System.currentTimeMillis();
        long elapsedTime = endTime - startTime;
        System.out.println("Elapsed time for getNumOfLines(): " + elapsedTime + " milliseconds ,num of lines: "+numOfLines);

        // Measure the execution time of the getNumOfLinesThreads() method
        startTime = System.currentTimeMillis();
        int numOfLinesThreads = Ex2_1.getNumOfLinesThreads(fileNames);
        endTime = System.currentTimeMillis();
        elapsedTime = endTime - startTime;
        System.out.println("Elapsed time for getNumOfLines(): " + elapsedTime + " milliseconds ,num of lines: "+numOfLinesThreads);

        // Measure the execution time of the getNumOfLinesThreadPool() method
        startTime = System.currentTimeMillis();
        int numOfLinesThreadPool = Ex2_1.getNumOfLinesThreadPool(fileNames);
        endTime = System.currentTimeMillis();
        elapsedTime = endTime - startTime;
        System.out.println("Elapsed time for getNumOfLines(): " + elapsedTime + " milliseconds ,num of lines: "+numOfLinesThreadPool);
    }
}